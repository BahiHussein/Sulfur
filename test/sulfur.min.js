
const { faker } = require('@faker-js/faker');
const axios = require('axios');
const async = require('async');
const { nanoid } = require('nanoid');
let ejs = require('ejs');
const { readFile, writeFile } = require('fs/promises');
let path = require('path');



async function http({ method, url, body, headers, params } = {}) {

    let result = axios({
        method,
        url,
        data: body,
        headers,
        params,
    });
    return result;

}

const slugify = (text) => {
    const from = "Ã£Ã Ã¡Ã¤Ã¢áº½Ã¨Ã©Ã«ÃªÃ¬Ã­Ã¯Ã®ÃµÃ²Ã³Ã¶Ã´Ã¹ÃºÃ¼Ã»Ã±Ã§Â·/_,:;"
    const to = "aaaaaeeeeeiiiiooooouuuunc------"

    const newText = text.split('').map(
        (letter, i) => letter.replace(new RegExp(from.charAt(i), 'g'), to.charAt(i)))

    return newText
        .toString()                     // Cast to string
        .toLowerCase()                  // Convert the string to lowercase letters
        .trim()                         // Remove whitespace from both sides of a string
        .replace(/\s+/g, '-')           // Replace spaces with -
        .replace(/&/g, '-y-')           // Replace & with 'and'
        .replace(/[^\w\-]+/g, '')       // Remove all non-word chars
        .replace(/\-\-+/g, '-');        // Replace multiple - with single -
}

/**
* 
* @param {*} path 'a.b.c'
* @param {*} obj an object to extract value of 
*/
const getDeepValue = ({ path, obj }) => {
    for (var i = 0, path = path.split('.'), len = path.length; i < len; i++) {
        var level = obj[path[i]];
        if (!level) return null;
        obj = level;
    };
    return obj;
}

/**
* @param {*} path example 'a.b.c'
* @param {*} value what do you wanaa set at the path ex: 'hello'
* @param {*} obj the object that will be injected the path and value
*/
const setDeepValue = ({ path, value, obj, marker }) => {
    if (!marker) marker = '.'
    let pfs = path.split(marker);
    let deepRef = obj;

    for (let i = 0; i < pfs.length; i++) {
        if (deepRef[pfs[i]] === undefined || deepRef[pfs[i]] === null) {
            deepRef[pfs[i]] = {};
        }
        if (i == pfs.length - 1) {
            deepRef[pfs[i]] = value;
        } else {
            deepRef = deepRef[pfs[i]];
        }
    }
    return obj;
}










/** multiple steps with in the same scenario */
class Steps {
    constructor({ set, get, data }) {
        this.steps = [];
        this.set = set;
        this.get = get;
        this.data = data;

    }
    pass(when, payloadBuilder, assertFn=()=>{}) {
        return { when, payloadBuilder, assertFn, shouldPass: true }
    }
    fail(when, payloadBuilder, assertFn=()=>{}) {
        return { when, payloadBuilder, assertFn, shouldPass: false }
    }
    step(title, builderFn) {
        if(!builderFn) throw new Error('step builder is missing for title: ' + title);
        this.steps.push({ id: nanoid(), title, builder: builderFn });
        return this;
    }

    _clone(obj) {
        return Object.assign({}, obj);
    }


    _run(failed) {

        let stepsTasks = [];

        for (let i = 0; i < this.steps.length; i++) {

            stepsTasks.push((tcb) => {

                let step = this.steps[i];
                let result = step.builder({ set: this.set, get: this.get, data: this.data, pass: this.pass, fail: this.fail, faker: faker });
                
                console.log(result.rounds);

                result.id = nanoid();
                // if(result.rounds || result.rounds.length == 0) throw new Error("Rounds are required in step")
                

                let masterPayload = result.payload;

                /** the step of each should be processed in sequence as that may contribute to the steps sequence
                 * a fail scenario may be depending on the result of a data that has been set in a success 
                 */
                let roundTasks = [];
                for (let x = 0; x < result.rounds.length; x++) {
                    const round = result.rounds[x];
                    console.log("IN A ROUND--->")
                    roundTasks.push((rcb) => {
                        round.id = nanoid();
                        
                        /* creating a clone from the master payload to avoid changes in the master object  */
                        let masterClone = JSON.parse(JSON.stringify(masterPayload));
                        let payload = round.payloadBuilder(masterClone);

                        //console.log("Payload built-----");
                        //console.log(payload);

                        /** if the builder function didn't return a payload the master will be used */
                        let req = payload ? payload : masterClone;
                      
                        round.req = req;

                        http(round.req).then(result => {
                            let body = result.data;
                            let headers = result.headers;
                            let status = result.status;
                            let statusText = result.statusText;
                            
                            let httpPass = round.shouldPass ? true : false;
                            round.res = { pass: httpPass, body, headers, status, statusText };
                            round.passed = false;
                            round.assertPassed = false;
                            try {
                                round.assert = round.assertFn({ pass: httpPass, body, headers, status, statusText, req});
                            } catch(e){
                                console.log(e);
                                round.assert = e;
                            }
                            if(round.assert){
                                console.log("ðŸ‘˜")
                                round.assertPassed = false;
                            } else {
                                round.assertPassed = true;
                            }
                            if(httpPass && round.assertPassed){
                                round.passed = true;
                                rcb(null, {});
                            } else {
                                rcb(round, {});
                            }
                        }).catch(err => {
                            let body = err.response?.data;
                            let headers = err.response?.headers;
                            let status = err.response?.status;
                            let statusText = err.response?.statusText;
                            let httpPass = round.shouldPass ? false : true;
                            round.res = { pass: httpPass, body, headers, status, statusText };
                            round.assertPassed = false;

                            try {
                                 round.assert = round.assertFn({ pass: httpPass, body, headers, status, statusText, req});
                            } catch(e){
                                console.log(e);
                                round.assert = e;
                            }
                            if(round.assert){
                                console.log("ðŸ‘˜")
                                round.assertPassed = false;
                            } else {
                                round.assertPassed = true;
                            }
                            if(httpPass && round.assertPassed){
                                rcb(null, {});
                                round.passed = true;
                            } else {
                                rcb(round, {});
                            }
                        });


                    })

                }

                async.series(roundTasks).then(results => {
                    /** when all rounder passed under step */
                    this.steps[i].passed = true;
                    this.steps[i].runner = result;
                    try {
                        tcb(null, {});
                    } catch (err) {
                        console.log(err);
                    }
                    
                }).catch(err => {
                    console.log(err);
                    /** when one round failed under step */
                    this.steps[i].passed = false;
                    this.steps[i].runner = result;

                    try {
                        tcb(err, {});
                    } catch (err) {
                        console.log(err);
                    }
                   
                });

            });

        }

        
        async.series(stepsTasks).then(results => {
            /** when all steps under scenairo passed */
            failed(null);
            console.log('Scenario passed');
        }).catch(err => {
            /** when one step failed under scenario */
            failed(err);
            console.log('Scenario failed');
        });
    }
}

class Data {
    constructor() {
        this.data = {}
    }
    set(path, value) {
        return setDeepValue({ path, value, obj: this.data });
    }
    get(path) {
        let v = getDeepValue({ path, obj: this.data });
        return v;
    }
}
class Sulpher {
    constructor({title="Docs", version="0.0.0", desc="..."}={}) {
        this.title = title;
        this.version = version;
        this.desc = desc;
        this.scenarios = [];
        this.data = new Data();

    }


    /**
     * create a new testing scenario
     * @param {} param0 
     * @returns 
     */
    scenario(id, title="", desc="") {
        id = id ? slugify(id) : nanoid();

        let stepsInstance = new Steps({
            set: ((key, value) => {
                return this.data.set(`${id}.${key}`, value);
            }).bind(this),
            get: ((key) => {
                return this.data.get(`${id}.${key}`);
            }).bind(this),
            data: this.data,
        });

        this.scenarios.push({
            id,
            desc,
            title,
            steps: stepsInstance,
        });
        /** return the steps instance */
        return stepsInstance;
    }

    async render(){

        ejs.renderFile(path.join(__dirname,'./doc_template.ejs'), {
            plTypes: ['method', 'url', 'params', 'body', 'headers'],
            title: this.title, desc: this.desc, version: this.version, scenarios: this.scenarios
        }, {}, function(err, rendered){
            if(err){
                console.log(err);
            } else {
                try {
                    writeFile('./public/_docs/docs.html', rendered, 'utf8');
                } catch(e){
                    console.log(e);
                }
            }
            
        });

        
       
    }

    run() {
        let scenarioTasks = [];
        for (let i = 0; i < this.scenarios.length; i++) {
            scenarioTasks.push((cb) => {
                const scenario = this.scenarios[i];
                scenario.steps._run((error)=>{
                    /** if all steps>rounds under scenario finished successfully */
                    if(error){
                        /** should break the whole scenario */
                        scenario.passed = false;
                        cb(error);
                        
                    } else {
                        scenario.passed = true;
                        cb(null, {});
                    }
                });
                
            });
        }
        async.series(scenarioTasks).then(results => {
            console.log('All scenarios done');
            this.render();
        }).catch(err => {
            console.log(err);
            console.log('All scenarios failed');
            this.render()
        });
    }

    list() {
        return this.scenarios;
    }



}

module.exports = Sulpher;